#!/usr/bin/env python3
"""
Task Executor — Main orchestrator for Mobile Cobot Pick & Place.

Coordinates Nav2 (navigation) and MoveIt2 (manipulation) to:
1. Navigate to start_table
2. Pick each object in grasp_order
3. Navigate to target_table
4. Place object in metal box
5. Repeat for all objects

Usage (after Isaac Sim, Nav2, MoveIt2, and manipulation_server are running):
  ros2 run mobile_manipulation task_executor.py

Reads config from:
  - configs/input.json      (grasp_order, start_table, target_table)
  - configs/.env             (table positions, dimensions)
  - configs/object_positions.json  (spawned object positions from load_warehouse_env.py)
"""

import os
import json
import time
import math
import threading
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from geometry_msgs.msg import PoseStamped, Twist
from nav_msgs.msg import Odometry
from std_srvs.srv import Trigger
from mobile_manipulation.srv import GoToNamedTarget, GoToPose
from nav2_simple_commander.robot_navigator import BasicNavigator, TaskResult


# ==============================================================================
# CONSTANTS
# ==============================================================================

# Project directory (change if needed)
PROJECT_DIR = os.environ.get(
    'PROJECT_DIR',
    os.path.expanduser('~/Documents/Thinh_Dang/isaac-sim-mobile-cobot-pick-place'))

# Grasp parameters (tune these for your setup)
APPROACH_HEIGHT = 0.20   # Height above object for approach (meters)
GRASP_HEIGHT = 0.10      # Height above object for grasp — panda_link8 to fingertip ~0.10m
RETREAT_HEIGHT = 0.22    # Height above object for retreat (meters)
PLACE_HEIGHT = 0.08      # Height above place position for releasing (meters)
GRASP_PAUSE = 0.5        # Pause after gripper close/open (seconds)


class TaskExecutor(Node):
    def __init__(self):
        super().__init__('task_executor')

        # ----- Service clients for manipulation -----
        self.named_target_client = self.create_client(
            GoToNamedTarget, 'manipulation/go_to_named_target')
        self.pose_client = self.create_client(
            GoToPose, 'manipulation/go_to_pose')
        self.open_gripper_client = self.create_client(
            Trigger, 'manipulation/open_gripper')
        self.close_gripper_client = self.create_client(
            Trigger, 'manipulation/close_gripper')

        # ----- Navigation -----
        self.navigator = BasicNavigator(namespace='carter')

        # ----- Wheel lock: publish cmd_vel=0 to prevent robot drift during manipulation -----
        self.cmd_vel_pub = self.create_publisher(Twist, '/carter/cmd_vel', 10)
        self.wheel_lock_active = False
        self.wheel_lock_timer = None

        # ----- Odometry: read actual robot position -----
        self.odom_data = None
        best_effort_qos = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            history=HistoryPolicy.KEEP_LAST, depth=1)
        self.create_subscription(
            Odometry, '/carter/odom', self._odom_callback, best_effort_qos)

        # ----- Robot state (from odometry, in world frame) -----
        self.current_robot_x = 0.0
        self.current_robot_y = 0.0
        self.current_robot_yaw = -math.pi / 2  # Facing -Y

        # Home position (odom frame origin in world)
        self.home_x = -2.5
        self.home_y = -1.5
        self.home_yaw = -math.pi / 2

        # ----- Load configs -----
        self._load_configs()

    # ==========================================================================
    # CONFIG LOADING
    # ==========================================================================

    def _load_configs(self):
        """Load all configuration files."""
        # Load .env
        env_path = os.path.join(PROJECT_DIR, 'configs', '.env')
        self.env = {}
        if os.path.exists(env_path):
            with open(env_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, value = line.split('=', 1)
                        try:
                            self.env[key.strip()] = float(value.strip())
                        except ValueError:
                            self.env[key.strip()] = value.strip()

        # Load input.json
        input_path = os.path.join(PROJECT_DIR, 'configs', 'input.json')
        with open(input_path, 'r') as f:
            self.task_config = json.load(f)

        # Load object_positions.json (generated by load_warehouse_env.py)
        obj_pos_path = os.path.join(PROJECT_DIR, 'configs', 'object_positions.json')
        if os.path.exists(obj_pos_path):
            with open(obj_pos_path, 'r') as f:
                self.object_positions = json.load(f)
        else:
            self.get_logger().warn(
                f'object_positions.json not found at {obj_pos_path}. '
                f'Run load_warehouse_env.py first to generate it.')
            self.object_positions = {}

        # Calculate table navigation goals
        table1_x = self.env.get('TABLE_1_X', -4.0)
        table1_y = self.env.get('TABLE_1_Y', -3.0)
        table2_x = self.env.get('TABLE_2_X', -1.0)
        table2_y = self.env.get('TABLE_2_Y', -3.0)
        robot_dist = self.env.get('ROBOT_DISTANCE_FROM_TABLE', 0.5)

        self.table_poses = {
            1: {'x': table1_x, 'y': table1_y + robot_dist,
                'qx': 0.0, 'qy': 0.0, 'qz': -0.707, 'qw': 0.707},
            2: {'x': table2_x, 'y': table2_y + robot_dist,
                'qx': 0.0, 'qy': 0.0, 'qz': -0.707, 'qw': 0.707},
        }

        # Calculate place position (center of target table's metal box)
        target_table = self.task_config.get('target_table', 1)
        target_table_pos = [table1_x, table1_y] if target_table == 1 else [table2_x, table2_y]

        table_height = self.env.get('TABLE_HEIGHT', 0.65)
        table_top = self.env.get('TABLE_TOP_THICKNESS', 0.03)
        box_height = self.env.get('BOX_HEIGHT', 0.08)

        self.place_z = table_height + table_top + box_height + PLACE_HEIGHT
        self.place_position = {
            'x': target_table_pos[0],
            'y': target_table_pos[1],
            'z': self.place_z
        }

        # Read home position from env
        self.home_x = self.env.get('ROBOT_HOME_X', -2.5)
        self.home_y = self.env.get('ROBOT_HOME_Y', -1.5)
        self.home_yaw = self.env.get('ROBOT_HOME_YAW', -math.pi / 2)

        self.get_logger().info(f'Task config: {self.task_config}')
        self.get_logger().info(f'Object positions: {list(self.object_positions.keys())}')

    # ==========================================================================
    # ODOMETRY & WHEEL LOCK
    # ==========================================================================

    def _odom_callback(self, msg):
        """Update robot position from odometry (odom frame → world frame)."""
        p = msg.pose.pose.position
        o = msg.pose.pose.orientation

        # Odom position (relative to start)
        odom_x = p.x
        odom_y = p.y

        # Odom yaw
        odom_yaw = math.atan2(
            2.0 * (o.w * o.z + o.x * o.y),
            1.0 - 2.0 * (o.y * o.y + o.z * o.z))

        # Convert odom → world frame
        cos_h = math.cos(self.home_yaw)
        sin_h = math.sin(self.home_yaw)
        self.current_robot_x = self.home_x + cos_h * odom_x - sin_h * odom_y
        self.current_robot_y = self.home_y + sin_h * odom_x + cos_h * odom_y
        self.current_robot_yaw = self.home_yaw + odom_yaw
        self.odom_data = msg

    def lock_wheels(self):
        """Start publishing cmd_vel=0 at 10Hz to prevent robot drift."""
        if self.wheel_lock_active:
            return
        self.wheel_lock_active = True
        self.wheel_lock_timer = self.create_timer(0.1, self._publish_zero_vel)
        self.get_logger().info('  Wheels LOCKED')

    def unlock_wheels(self):
        """Stop publishing cmd_vel=0 to allow navigation."""
        if not self.wheel_lock_active:
            return
        self.wheel_lock_active = False
        if self.wheel_lock_timer:
            self.wheel_lock_timer.cancel()
            self.wheel_lock_timer = None
        self.get_logger().info('  Wheels UNLOCKED')

    def _publish_zero_vel(self):
        """Publish zero velocity to hold robot in place."""
        self.cmd_vel_pub.publish(Twist())

    def read_robot_position(self):
        """Read current robot position from odometry and log it."""
        # Spin multiple times to ensure latest odom is processed
        for _ in range(30):
            rclpy.spin_once(self, timeout_sec=0.05)

        self.get_logger().info(
            f'  Robot actual position: ({self.current_robot_x:.3f}, '
            f'{self.current_robot_y:.3f}), yaw={math.degrees(self.current_robot_yaw):.1f}°')

    # ==========================================================================
    # SERVICE HELPERS
    # ==========================================================================

    def _call_service(self, client, request):
        """Synchronous service call with timeout."""
        future = client.call_async(request)
        rclpy.spin_until_future_complete(self, future, timeout_sec=60.0)
        if future.result() is None:
            self.get_logger().error('Service call timed out!')
            return None
        return future.result()

    def go_to_named_target(self, name):
        """Move arm to named target. Returns True on success."""
        self.get_logger().info(f'  Arm → {name}')
        req = GoToNamedTarget.Request()
        req.target_name = name
        resp = self._call_service(self.named_target_client, req)
        if resp is None:
            return False
        if not resp.success:
            self.get_logger().error(f'  Failed: {resp.message}')
        return resp.success

    def _odom_to_panda_link0(self, ox, oy, oz):
        """Convert position from odom frame to panda_link0 frame.

        Uses current robot position (from navigation goal) and known
        panda_link0 mount height (0.4125m above chassis_link).
        """
        # panda_link0 is at robot position + Z offset
        panda_z_offset = 0.4125  # chassis_link → panda_link0 height

        # Delta in odom frame
        dx = ox - self.current_robot_x
        dy = oy - self.current_robot_y
        dz = oz - panda_z_offset

        # Rotate by inverse of robot yaw to get body frame
        # R^(-1)(yaw) = R(-yaw)
        cos_yaw = math.cos(-self.current_robot_yaw)
        sin_yaw = math.sin(-self.current_robot_yaw)

        lx = cos_yaw * dx - sin_yaw * dy
        ly = sin_yaw * dx + cos_yaw * dy
        lz = dz

        return lx, ly, lz

    def go_to_pose(self, x, y, z, frame_id='odom', cartesian=False):
        """Move arm to pose (top-down grasp orientation). Returns True on success.

        Converts position from odom frame to panda_link0 frame using the
        known robot position (set after navigation). This avoids TF issues.
        """
        # Convert odom → panda_link0
        lx, ly, lz = self._odom_to_panda_link0(x, y, z)

        # Build pose in panda_link0 frame
        pose = PoseStamped()
        pose.header.frame_id = 'panda_link0'
        pose.pose.position.x = lx
        pose.pose.position.y = ly
        pose.pose.position.z = lz
        # Top-down grasp: gripper pointing down (-Z of panda_link0)
        # 180° rotation around Y-axis: q = (x=0, y=1, z=0, w=0)
        # This is the standard Panda top-down orientation
        pose.pose.orientation.x = 0.0
        pose.pose.orientation.y = 1.0
        pose.pose.orientation.z = 0.0
        pose.pose.orientation.w = 0.0

        self.get_logger().info(
            f'  Arm → pose odom[{x:.3f}, {y:.3f}, {z:.3f}] '
            f'→ panda_link0[{lx:.3f}, {ly:.3f}, {lz:.3f}] '
            f'({"cartesian" if cartesian else "free-space"})')

        req = GoToPose.Request()
        req.target_pose = pose
        req.cartesian_path = cartesian
        resp = self._call_service(self.pose_client, req)
        if resp is None:
            return False
        if not resp.success:
            self.get_logger().error(f'  Failed: {resp.message}')
        return resp.success

    def open_gripper(self):
        """Open gripper. Returns True on success."""
        self.get_logger().info('  Gripper → open')
        resp = self._call_service(self.open_gripper_client, Trigger.Request())
        return resp is not None and resp.success

    def close_gripper(self):
        """Close gripper. Returns True on success."""
        self.get_logger().info('  Gripper → close')
        resp = self._call_service(self.close_gripper_client, Trigger.Request())
        return resp is not None and resp.success

    # ==========================================================================
    # NAVIGATION
    # ==========================================================================

    def navigate_to_table(self, table_number):
        """Navigate to table using Nav2. Returns True on success."""
        if table_number not in self.table_poses:
            self.get_logger().error(f'Invalid table number: {table_number}')
            return False

        pose_data = self.table_poses[table_number]

        goal_pose = PoseStamped()
        goal_pose.header.frame_id = 'map'
        goal_pose.header.stamp = self.navigator.get_clock().now().to_msg()
        goal_pose.pose.position.x = pose_data['x']
        goal_pose.pose.position.y = pose_data['y']
        goal_pose.pose.position.z = 0.0
        goal_pose.pose.orientation.x = pose_data['qx']
        goal_pose.pose.orientation.y = pose_data['qy']
        goal_pose.pose.orientation.z = pose_data['qz']
        goal_pose.pose.orientation.w = pose_data['qw']

        self.get_logger().info(
            f'  Navigate → Table {table_number} '
            f'({pose_data["x"]:.2f}, {pose_data["y"]:.2f})')

        self.navigator.goToPose(goal_pose)

        while not self.navigator.isTaskComplete():
            feedback = self.navigator.getFeedback()
            # Could add timeout check here

        result = self.navigator.getResult()
        if result == TaskResult.SUCCEEDED:
            # Read ACTUAL robot position from odometry (not nav goal)
            time.sleep(0.5)  # Wait for odom to settle
            self.read_robot_position()
            self.get_logger().info(
                f'  Reached Table {table_number}! '
                f'Robot at ({self.current_robot_x:.3f}, {self.current_robot_y:.3f})')
            return True
        else:
            self.get_logger().error(f'  Navigation failed: {result}')
            return False

    # ==========================================================================
    # PICK & PLACE
    # ==========================================================================

    def pick_object(self, object_name):
        """
        Pick sequence for an object.
        Assumes robot is already at the start table.
        """
        if object_name not in self.object_positions:
            self.get_logger().error(f'Object position unknown: {object_name}')
            return False

        pos = self.object_positions[object_name]
        obj_x, obj_y, obj_z = pos['x'], pos['y'], pos['z']

        self.get_logger().info(f'  PICK {object_name} at [{obj_x:.3f}, {obj_y:.3f}, {obj_z:.3f}]')

        # Step 1: Open gripper
        if not self.open_gripper():
            return False

        # Step 2: Arm to ready pose
        if not self.go_to_named_target('ready'):
            return False

        # Step 3: Move above object (free-space)
        if not self.go_to_pose(obj_x, obj_y, obj_z + APPROACH_HEIGHT):
            return False

        # Step 4: Move down to object (Cartesian — straight line)
        if not self.go_to_pose(obj_x, obj_y, obj_z + GRASP_HEIGHT, cartesian=True):
            return False

        # Step 5: Close gripper to grasp
        if not self.close_gripper():
            return False
        time.sleep(GRASP_PAUSE)

        # Step 6: Retreat up (Cartesian)
        if not self.go_to_pose(obj_x, obj_y, obj_z + RETREAT_HEIGHT, cartesian=True):
            return False

        # Step 7: Back to ready (intermediate before stowed_back)
        self.go_to_named_target('ready')

        self.get_logger().info(f'  PICK {object_name} — done!')
        return True

    def place_object(self, object_name, place_index):
        """
        Place sequence — place object in target table's metal box.
        Assumes robot is already at the target table.
        """
        # Offset each object slightly so they don't stack
        offset_x = (place_index % 2) * 0.06 - 0.03
        offset_y = (place_index // 2) * 0.06 - 0.03

        px = self.place_position['x'] + offset_x
        py = self.place_position['y'] + offset_y
        pz = self.place_position['z']

        self.get_logger().info(f'  PLACE {object_name} at [{px:.3f}, {py:.3f}, {pz:.3f}]')

        # Step 1: Arm to ready pose
        if not self.go_to_named_target('ready'):
            return False

        # Step 2: Move above place position (free-space)
        if not self.go_to_pose(px, py, pz + APPROACH_HEIGHT):
            return False

        # Step 3: Move down (Cartesian)
        if not self.go_to_pose(px, py, pz, cartesian=True):
            return False

        # Step 4: Open gripper to release
        if not self.open_gripper():
            return False
        time.sleep(GRASP_PAUSE)

        # Step 5: Retreat up (Cartesian)
        if not self.go_to_pose(px, py, pz + RETREAT_HEIGHT, cartesian=True):
            return False

        # Step 6: Back to ready (intermediate before stowed_back)
        self.go_to_named_target('ready')

        self.get_logger().info(f'  PLACE {object_name} — done!')
        return True

    # ==========================================================================
    # MAIN TASK EXECUTION
    # ==========================================================================

    def execute_task(self):
        """Main task execution loop — pick all objects and place them."""
        grasp_order = self.task_config['grasp_order']
        start_table = self.task_config['start_table']
        target_table = self.task_config['target_table']

        self.get_logger().info('=' * 60)
        self.get_logger().info('STARTING PICK & PLACE TASK')
        self.get_logger().info(f'  Grasp order  : {grasp_order}')
        self.get_logger().info(f'  Start table  : {start_table}')
        self.get_logger().info(f'  Target table : {target_table}')
        self.get_logger().info('=' * 60)

        # Stow arm before starting
        self.go_to_named_target('stowed_back')

        for i, obj_name in enumerate(grasp_order):
            self.get_logger().info('')
            self.get_logger().info(f'=== Object {i + 1}/{len(grasp_order)}: {obj_name} ===')

            # --- NAVIGATE TO START TABLE ---
            self.unlock_wheels()  # Allow navigation
            self.get_logger().info(f'[{obj_name}] Step 1: Navigate to start table {start_table}')
            if not self.navigate_to_table(start_table):
                self.get_logger().error(f'[{obj_name}] Navigation to start table failed! Skipping.')
                continue

            # --- LOCK WHEELS & PICK ---
            self.lock_wheels()  # Prevent drift during manipulation
            self.read_robot_position()  # Get actual position from odom
            self.get_logger().info(f'[{obj_name}] Step 2: Pick object')
            if not self.pick_object(obj_name):
                self.get_logger().error(f'[{obj_name}] Pick failed! Skipping.')
                self.go_to_named_target('stowed_back')
                self.unlock_wheels()
                continue

            # --- STOW ARM FOR NAVIGATION ---
            self.get_logger().info(f'[{obj_name}] Step 3: Stow arm for navigation')
            self.go_to_named_target('stowed_back')
            self.unlock_wheels()  # Allow navigation

            # --- NAVIGATE TO TARGET TABLE ---
            self.get_logger().info(f'[{obj_name}] Step 4: Navigate to target table {target_table}')
            if not self.navigate_to_table(target_table):
                self.get_logger().error(f'[{obj_name}] Navigation to target table failed! Skipping.')
                continue

            # --- LOCK WHEELS & PLACE ---
            self.lock_wheels()  # Prevent drift during manipulation
            self.read_robot_position()  # Get actual position from odom
            self.get_logger().info(f'[{obj_name}] Step 5: Place object')
            if not self.place_object(obj_name, i):
                self.get_logger().error(f'[{obj_name}] Place failed!')

            # --- STOW ARM ---
            self.get_logger().info(f'[{obj_name}] Step 6: Stow arm')
            self.go_to_named_target('stowed_back')
            self.unlock_wheels()  # Allow navigation for next object

            self.get_logger().info(f'=== {obj_name} complete! ===')

        self.get_logger().info('')
        self.get_logger().info('=' * 60)
        self.get_logger().info('TASK COMPLETE! All objects processed.')
        self.get_logger().info('=' * 60)


def main(args=None):
    rclpy.init(args=args)
    executor = TaskExecutor()

    # Wait for all services
    executor.get_logger().info('Waiting for manipulation services...')
    executor.named_target_client.wait_for_service()
    executor.pose_client.wait_for_service()
    executor.open_gripper_client.wait_for_service()
    executor.close_gripper_client.wait_for_service()
    executor.get_logger().info('Manipulation services available!')

    # Wait for Nav2
    executor.get_logger().info('Waiting for Nav2 to be active...')
    executor.navigator.waitUntilNav2Active()
    executor.get_logger().info('Nav2 is active!')

    # Execute the pick-and-place task
    executor.execute_task()

    rclpy.shutdown()


if __name__ == '__main__':
    main()
